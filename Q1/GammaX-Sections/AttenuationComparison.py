##preamble

import numpy as np
from scipy import optimize
import matplotlib.pyplot as plt
from matplotlib.legend_handler import HandlerTuple

## Data Induction
print(energies) #generated by Attenuation.py -- run those cells in the same kernel as this script

NistDataPath = 'C:/Users/jdewh/OneDrive - The University of Chicago/Third Year/PHYS 211/Q1/GammaX-Sections/nist_mu_al.txt'

savePath = 'C:/Users/jdewh/OneDrive - The University of Chicago/Third Year/PHYS 211/Q1/GammaX-Sections/AttenuationComparison.png'

NistVals = np.loadtxt(NistDataPath, unpack=True, skiprows=1)

print(NistVals[:, :3])
NistVals[1] *= .1 #unit conversion: cm^{-1} -> mm^{-1}
print(NistVals[:, :3])


#find bounds of relevant data
emin = min(energies)
emax = max(energies)

eminIndex = 0
emaxIndex = 0

for i, e in enumerate(NistVals[0]):
    if(e >= emin and eminIndex == 0):
        eminIndex = i - 4
    if(e > emax):
        emaxIndex = i +2
        break

print(eminIndex, emaxIndex)

#programming uncertainties in NIST data

refUncertainty = .03 #from wiki, assume 3% error on all NIST values

NISTUB = NistVals[1] * (1 + refUncertainty)
NISTLB = NistVals[1] * (1 - refUncertainty)




## Plotting Attenuation Coefficients
plt.clf()

plt.figure(figsize=(8,6))
plt.title('Measured Attenuation Coefficients vs NIST Data')
plt.xlabel('Energy (keV)')
plt.xscale('log')
plt.ylabel('Attenuation Coefficient (mm$^{-1}$)')
plt.yscale('log')

pCent, = plt.plot(NistVals[0][eminIndex:emaxIndex], NistVals[1][eminIndex:emaxIndex], 'k-', lw='.5', markersize=1)
pUB, = plt.plot(NistVals[0][eminIndex:emaxIndex], NISTUB[eminIndex:emaxIndex], ls='--', color='gray', lw='.5', markersize=1)
pLB, = plt.plot(NistVals[0][eminIndex:emaxIndex], NISTLB[eminIndex:emaxIndex], ls='--', color='gray', lw='.5', markersize=1)
vals = plt.errorbar(energies, coeffs, dcoeffs, fmt='r.', lw=1, markersize=2, capsize=3)

plt.legend( [pCent, (pUB, pLB), vals], ['NIST Reported Values', 'NIST Values Error bounds', 'Measured Values'], handler_map={tuple: HandlerTuple(ndivide=None)}, loc='upper right')
#plt.savefig(savePath)
plt.show()


## Linear Interpolation

def interpolate(energy):
    #find which two points 'energy' is between:
    j1 = 0
    j2 = 0
    for i in range(len(NistVals[0])):
        if NistVals[0][i] >= energy:
            j1 = i-1
            j2 = i
            break


    #interpolate lambda
    t = (float(energy) - NistVals[0][j1]) / (NistVals[0][j2] - NistVals[0][j1])
    out = t * NistVals[1][j2] + (1-t)* NistVals[1][j1]
    return out
